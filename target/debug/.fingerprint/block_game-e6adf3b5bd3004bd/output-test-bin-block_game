{"message":"value assigned to `shader_program` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1501,"byte_end":1515,"line_start":66,"line_end":66,"column_start":13,"column_end":27,"is_primary":true,"text":[{"text":"    let mut shader_program = 0;","highlight_start":13,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_assignments)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: value assigned to `shader_program` is never read\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:66:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut shader_program = 0;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: maybe it is overwritten before being read?\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_assignments)]` on by default\u001b[0m\n\n"}
{"message":"variable `FRAG_SHADER` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1555,"byte_end":1566,"line_start":69,"line_end":69,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let FRAG_SHADER = std::fs::read_to_string(\"src/fragment.vert\").expect(\"Failed to read fragment shader.\");","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(non_snake_case)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1555,"byte_end":1566,"line_start":69,"line_end":69,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let FRAG_SHADER = std::fs::read_to_string(\"src/fragment.vert\").expect(\"Failed to read fragment shader.\");","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":"frag_shader","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `FRAG_SHADER` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:69:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let FRAG_SHADER = std::fs::read_to_string(\"src/fragment.vert\").expect(\"Failed to read fragment shader.\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `frag_shader`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_snake_case)]` on by default\u001b[0m\n\n"}
{"message":"variable `GEOM_SHADER` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1665,"byte_end":1676,"line_start":70,"line_end":70,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let GEOM_SHADER = std::fs::read_to_string(\"src/geometry.vert\").expect(\"Failed to read geometry shader.\");","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1665,"byte_end":1676,"line_start":70,"line_end":70,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let GEOM_SHADER = std::fs::read_to_string(\"src/geometry.vert\").expect(\"Failed to read geometry shader.\");","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":"geom_shader","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `GEOM_SHADER` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:70:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let GEOM_SHADER = std::fs::read_to_string(\"src/geometry.vert\").expect(\"Failed to read geometry shader.\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `geom_shader`\u001b[0m\n\n"}
{"message":"variable `VERT_SHADER` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1775,"byte_end":1786,"line_start":71,"line_end":71,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let VERT_SHADER = std::fs::read_to_string(\"src/vertex.vert\").expect(\"Failed to read vertex shader.\");","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1775,"byte_end":1786,"line_start":71,"line_end":71,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let VERT_SHADER = std::fs::read_to_string(\"src/vertex.vert\").expect(\"Failed to read vertex shader.\");","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":"vert_shader","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `VERT_SHADER` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:71:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let VERT_SHADER = std::fs::read_to_string(\"src/vertex.vert\").expect(\"Failed to read vertex shader.\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `vert_shader`\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":9212,"byte_end":9218,"line_start":330,"line_end":330,"column_start":134,"column_end":140,"is_primary":true,"text":[{"text":"            let cam_pos_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_pos\").expect(\"CString::new failed\").as_ptr());","highlight_start":134,"highlight_end":140}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9148,"byte_end":9211,"line_start":330,"line_end":330,"column_start":70,"column_end":133,"is_primary":false,"text":[{"text":"            let cam_pos_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_pos\").expect(\"CString::new failed\").as_ptr());","highlight_start":70,"highlight_end":133}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(temporary_cstring_as_ptr)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:330:134\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m330\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mLocation(shader_program, std::ffi::CString::new(\"cam_pos\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(temporary_cstring_as_ptr)]` on by default\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":9356,"byte_end":9362,"line_start":331,"line_end":331,"column_start":134,"column_end":140,"is_primary":true,"text":[{"text":"            let cam_ang_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_ang\").expect(\"CString::new failed\").as_ptr());","highlight_start":134,"highlight_end":140}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9292,"byte_end":9355,"line_start":331,"line_end":331,"column_start":70,"column_end":133,"is_primary":false,"text":[{"text":"            let cam_ang_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_ang\").expect(\"CString::new failed\").as_ptr());","highlight_start":70,"highlight_end":133}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:331:134\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mLocation(shader_program, std::ffi::CString::new(\"cam_ang\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":9502,"byte_end":9508,"line_start":332,"line_end":332,"column_start":136,"column_end":142,"is_primary":true,"text":[{"text":"            let cam_fovx_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_fovx\").expect(\"CString::new failed\").as_ptr());","highlight_start":136,"highlight_end":142}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9437,"byte_end":9501,"line_start":332,"line_end":332,"column_start":71,"column_end":135,"is_primary":false,"text":[{"text":"            let cam_fovx_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_fovx\").expect(\"CString::new failed\").as_ptr());","highlight_start":71,"highlight_end":135}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:332:136\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m332\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mLocation(shader_program, std::ffi::CString::new(\"cam_fovx\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":9648,"byte_end":9654,"line_start":333,"line_end":333,"column_start":136,"column_end":142,"is_primary":true,"text":[{"text":"            let cam_fovy_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_fovy\").expect(\"CString::new failed\").as_ptr());","highlight_start":136,"highlight_end":142}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9583,"byte_end":9647,"line_start":333,"line_end":333,"column_start":71,"column_end":135,"is_primary":false,"text":[{"text":"            let cam_fovy_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"cam_fovy\").expect(\"CString::new failed\").as_ptr());","highlight_start":71,"highlight_end":135}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:333:136\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mLocation(shader_program, std::ffi::CString::new(\"cam_fovy\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":9797,"byte_end":9803,"line_start":335,"line_end":335,"column_start":138,"column_end":144,"is_primary":true,"text":[{"text":"            let light_pos_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_pos\").expect(\"CString::new failed\").as_ptr());","highlight_start":138,"highlight_end":144}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9731,"byte_end":9796,"line_start":335,"line_end":335,"column_start":72,"column_end":137,"is_primary":false,"text":[{"text":"            let light_pos_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_pos\").expect(\"CString::new failed\").as_ptr());","highlight_start":72,"highlight_end":137}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:335:138\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m335\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mLocation(shader_program, std::ffi::CString::new(\"light_pos\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":9949,"byte_end":9955,"line_start":336,"line_end":336,"column_start":142,"column_end":148,"is_primary":true,"text":[{"text":"            let light_color_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_color\").expect(\"CString::new failed\").as_ptr());","highlight_start":142,"highlight_end":148}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9881,"byte_end":9948,"line_start":336,"line_end":336,"column_start":74,"column_end":141,"is_primary":false,"text":[{"text":"            let light_color_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_color\").expect(\"CString::new failed\").as_ptr());","highlight_start":74,"highlight_end":141}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:336:142\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m336\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mcation(shader_program, std::ffi::CString::new(\"light_color\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":10107,"byte_end":10113,"line_start":337,"line_end":337,"column_start":148,"column_end":154,"is_primary":true,"text":[{"text":"            let light_strength_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_strength\").expect(\"CString::new failed\").as_ptr());","highlight_start":148,"highlight_end":154}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10036,"byte_end":10106,"line_start":337,"line_end":337,"column_start":77,"column_end":147,"is_primary":false,"text":[{"text":"            let light_strength_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_strength\").expect(\"CString::new failed\").as_ptr());","highlight_start":77,"highlight_end":147}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:337:148\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mcation(shader_program, std::ffi::CString::new(\"light_strength\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\n"}
{"message":"getting the inner pointer of a temporary `CString`","code":{"code":"temporary_cstring_as_ptr","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":10261,"byte_end":10267,"line_start":338,"line_end":338,"column_start":144,"column_end":150,"is_primary":true,"text":[{"text":"            let light_radius_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_radius\").expect(\"CString::new failed\").as_ptr());","highlight_start":144,"highlight_end":150}],"label":"this pointer will be invalid","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10192,"byte_end":10260,"line_start":338,"line_end":338,"column_start":75,"column_end":143,"is_primary":false,"text":[{"text":"            let light_radius_loc = gl::GetUniformLocation(shader_program, std::ffi::CString::new(\"light_radius\").expect(\"CString::new failed\").as_ptr());","highlight_start":75,"highlight_end":143}],"label":"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see https://doc.rust-lang.org/reference/destructors.html","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: getting the inner pointer of a temporary `CString`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:338:144\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m338\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mcation(shader_program, std::ffi::CString::new(\"light_radius\").expect(\"CString::new failed\").as_ptr());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mthis pointer will be invalid\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for more information, see https://doc.rust-lang.org/reference/destructors.html\u001b[0m\n\n"}
{"message":"12 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 12 warnings emitted\u001b[0m\n\n"}
